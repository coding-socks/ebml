// +build codegen

// This program generates schema.go.

package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"golang.org/x/tools/imports"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var header = []byte(`// Code generated by go run make_schema.go. DO NOT EDIT.

package matroska

`)

func main() {
	filename := "schema.go"
	buf := bytes.NewBuffer(header)

	gen(buf)

	out, err := imports.Process(filename, buf.Bytes(), nil)
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile(filename, out, 0666)
	if err != nil {
		log.Fatal(err)
	}
}

var (
	definitionPurpose = "definition"
	rationalePurpose  = "rationale"
	referencesPurpose = "references"
	usageNotesPurpose = "usage notes"
)

type documentation struct {
	Content string `xml:",chardata"`
	Lang    string `xml:"lang,attr"`
	Purpose string `xml:"purpose"`
}

var (
	minOccursNoteAttribute = "minOccurs"
	maxOccursNoteAttribute = "maxOccurs"
	rangeNoteAttribute     = "range"
	lengthNoteAttribute    = "length"
	defaultNoteAttribute   = "default"
	minverNoteAttribute    = "minver"
	maxverNoteAttribute    = "maxver"
)

type note struct {
	Content       string `xml:",chardata"`
	NoteAttribute string `xml:"note_attribute,attr"`
}

type enum struct {
	Documentation []documentation `xml:"documentation"`
	Label         string          `xml:"label,attr"`
	Value         string          `xml:"value,attr"`
}

type restriction struct {
	Enum []enum `xml:"enum"`
}

type extension struct {
	Type       string     `xml:"type,attr"`
	Attributes []xml.Attr `xml:",any,attr"`
}

var (
	integerType  = "integer"
	uintegerType = "uinteger"
	floatType    = "float"
	stringType   = "string"
	dateType     = "date"
	utf8Type     = "utf-8"
	masterType   = "master"
	binaryType   = "binary"
)

type element struct {
	Documentation      []documentation `xml:"documentation"`
	ImplementationNote []note          `xml:"implementation_note"`
	Restriction        *restriction    `xml:"restriction"`
	Extension          []extension     `xml:"extension"`

	Name               string `xml:"name,attr"`
	Path               string `xml:"path,attr"`
	ID                 string `xml:"id,attr"`
	MinOccurs          int    `xml:"minOccurs,attr"`
	MaxOccurs          int    `xml:"maxOccurs,attr"`
	Range              string `xml:"range,attr"`
	Length             string `xml:"length,attr"`
	Default            string `xml:"default,attr"`
	Type               string `xml:"type,attr"`
	UnknownSizeAllowed bool   `xml:"unknownsizeallowed,attr"`
	Recursive          bool   `xml:"recursive,attr"`
	Recurring          bool   `xml:"recurring,attr"`
	MinVer             int    `xml:"minver,attr"`
	MaxVer             int    `xml:"maxver,attr"`
}

func (s *element) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type fw element // prevent recursion
	item := fw{
		MinOccurs: 0, // default="0"
		// TODO: consider using pointer to differentiate between not set and real value
		// [...] If the maxOccurs attribute is not present, then there is no
		// upper bound for the permitted number of occurrences [...]
		// https://www.rfc-editor.org/rfc/rfc8794#name-maxoccurs
		MaxOccurs:          0,     // default="1"
		UnknownSizeAllowed: false, // default="false"
		Recursive:          false, // default="false"
		Recurring:          false, // default="false"
		MinVer:             1,     // default="1"
	}
	if err := d.DecodeElement(&item, &start); err != nil {
		return err
	}
	*s = (element)(item)
	return nil
}

type schema struct {
	Element []element `xml:"element"`

	DocType string `xml:"docType,attr"`
	Version int    `xml:"version,attr"`
	EBML    uint   `xml:"ebml,attr"`
}

// https://stackoverflow.com/a/26957888/2231168
func (s *schema) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type fw schema // prevent recursion
	item := fw{
		EBML: 1, // default="1"
	}
	if err := d.DecodeElement(&item, &start); err != nil {
		return err
	}
	*s = (schema)(item)
	return nil
}

type treeNode struct {
	el       element
	children map[string]*treeNode
	cOrder   []string
}

func (n *treeNode) Put(key string, el *treeNode) {
	if _, ok := n.children[key]; !ok {
		n.cOrder = append(n.cOrder, key)
	}
	n.children[key] = el
}

func (n *treeNode) Get(key string) *treeNode {
	return n.children[key]
}

func (n *treeNode) VisitAll(f func(node *treeNode)) {
	for _, key := range n.cOrder {
		f(n.children[key])
	}
}

func gen(w io.Writer) {
	root := &treeNode{
		el: element{
			Type: masterType,
			Name: "Document",
		},
		children: make(map[string]*treeNode),
	}
	for _, fp := range []string{filepath.Join("..", "ebml.xml"), filepath.Join(".", "ebml_matroska.xml")} {
		var s schema
		func() {
			f, err := os.Open(fp)
			if err != nil {
				log.Fatal(err)
			}
			defer f.Close()
			if err := xml.NewDecoder(f).Decode(&s); err != nil {
				log.Fatal(err)
			}
		}()
		for _, el := range s.Element {
			if el.Path == `\(-\)Void` || el.Path == `\(1-\)CRC-32` {
				// TODO: Implement support for Void and CRC-32 tags
				continue
			}
			p := strings.Split(el.Path, `\`)[1:]
			branch := root
			lastIndex := len(p) - 1
			for _, s := range p[:lastIndex] {
				node := branch.Get(s)
				if node == nil {
					node = &treeNode{
						children: make(map[string]*treeNode),
					}
					branch.Put(s, node)
				}
				branch = node
			}
			branch.Put(p[lastIndex], &treeNode{
				el:       el,
				children: make(map[string]*treeNode),
			})
		}
	}
	write(w, root)
}

func write(w io.Writer, node *treeNode) {
	if node.el.Type != masterType {
		return
	}
	node.VisitAll(func(n *treeNode) {
		write(w, n)
	})
	fmt.Fprintf(w, "type %s struct {", node.el.Name)
	node.VisitAll(func(n *treeNode) {
		if n.el.MaxOccurs != 1 {
			fmt.Fprintf(w, "\n\t%s []%s `ebml:\"%s\"`", n.el.Name, resolveGoTye(n.el.Type, n.el.Name), n.el.ID)
		} else {
			fmt.Fprintf(w, "\n\t%s %s `ebml:\"%s\"`", n.el.Name, resolveGoTye(n.el.Type, n.el.Name), n.el.ID)
		}
	})
	fmt.Fprint(w, "\n}\n\n")
}

func resolveGoTye(s, name string) string {
	switch s {
	case integerType:
		return "int"
	case uintegerType:
		return "uint"
	case floatType:
		return "float64"
	case stringType:
		// TODO: Think how should enforce ASCII only characters (in the range of 0x20 to 0x7E).
		//  https://www.rfc-editor.org/rfc/rfc8794#name-string-element
		return "string"
	case dateType:
		return "time.Time"
	case utf8Type:
		// TODO: documentation states `string` but `[]byte` might be more appropriate
		//  depending on the length.
		//  https://www.rfc-editor.org/rfc/rfc8794#name-utf-8-element
		return "[]byte"
	case masterType:
		return name
	case binaryType:
		return "[]byte"
	}
	return s
}
